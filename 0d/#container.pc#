constructor Container (𝜌childrenArray 𝜌map) {
    // api for every Component
    š.reset = λreset
    š.❲completed ?❳ = λ❲completed ?❳
    š.handle = λhandle
    š.step = λstep
    š.setChildren = λsetChildren
    š.setRoutings = λsetRoutings
    š.outputs = []

    // helper functions
    š.internal_acceptInput = λacceptInput
    š.internal_mergeOutputs = λmergeOutputs
    š.internal_route = λroute
    š.internal_runToCompletion = λrunToCompletion

    ∀ 𝜌childrenArray child {
	š ⇒ child.container
    }
    𝜌childrenArray ⇒ š.children

    𝜌map ⇒ š.routingMap
}

procedure reset () {
    ∀ š.children.forEach child {
	child/reset
    }
}

function ❲completed ?❳ {
    var done = true
    ∀ š.children child {
	done = done & child.❲completed ?❳
    }
    done
}

function handle (message) {
    š.reset ()
    if (š.isCompleted ()) {
	throw "internal error: container.handle called on completed container"
    }
    š.internal_acceptInput (message)
    function send (port, data) {
	š.outputs.push (new messageClass.Message (port, data, this, message))
    }
    š.internal_runToCompletion (send)
    š.outputs.push (new messageClass.Message ('$out', null, this, message))
}

function acceptInput (message) {
    š.outputs = []
    š.routingMap.forEach (connection => {
	if ("down" == connection.direction) {
	    var m = new messageClass.Message (connection.port, message.data, this, message)
	    var childOutputs = connection.receiver.handle (m, sendFunction)
	    š.outputs = š.internal_mergeOutputs (outputs, childOutputs)
	} else if ("passthrough" == connection.direction) {
	    var childOutputs = new messageClass.Message (connection.port, message.data, this, message)
	    š.outputs = š.internal_mergeOutputs (š.outputs, childOutputs)
	}
    })    
}

function mergeOutputs (outputs, childOutputs) {
    // outputs & childOutputs are queues
    // copy from least recent to most recent
    var clonedOuts = Array.from (outputs)
    var childOuts = childOutputs.reverse ()
    childOuts.forEach (cout => {
	clonedOutputs.push (cout)
    })
    return clonedOutputs
}

function runToCompletion (sendFunction) {
    while (! š.completed ()) {
	š.step (sendFunction)
	š.route (sendFunction)
    }
}

function step (sendFunction) {
    š.children.forEach (child => {
	child.step (sendFunction)
    })
}

function route (sendFunction) {
    š.routingMap.forEach (connection => {
	var deferredMessageStack = []
	if ("across" == connection.direction) {
	    var outputMessage = connection.sender.outputQueue [connection.sender.port]
	    var message = new messageClass.Message (connection.receiver.port, outputMessage.data, connection.sender, outputMessage)
	    deferredMessageStack.push ({'target': connection.receiver, 'message': message})
	} else if ("up" == connection.direction) {
	    var outputMessage = connection.sender.outputQueue [connection.sender.port]
	    var message = new messageClass.Message (connection.receiver.port, outputMessage.data, connection.sender, outputMessage)
	    send (connection.receiver.port, message)
	}
	deferredMessageStack.forEach (pair => {
	    pair.target.handle (pair.message, sendFunction)
	})
    })
}

