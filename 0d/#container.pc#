constructor Container (ğœŒchildrenArray ğœŒmap) {
    // api for every Component
    Å¡.reset = Î»reset
    Å¡.â²completed ?â³ = Î»â²completed ?â³
    Å¡.handle = Î»handle
    Å¡.step = Î»step
    Å¡.setChildren = Î»setChildren
    Å¡.setRoutings = Î»setRoutings
    Å¡.outputs = []

    // helper functions
    Å¡.internal_acceptInput = Î»acceptInput
    Å¡.internal_mergeOutputs = Î»mergeOutputs
    Å¡.internal_route = Î»route
    Å¡.internal_runToCompletion = Î»runToCompletion

    âˆ€ ğœŒchildrenArray child {
	Å¡ â‡’ child.container
    }
    ğœŒchildrenArray â‡’ Å¡.children

    ğœŒmap â‡’ Å¡.routingMap
}

procedure reset () {
    âˆ€ Å¡.children.forEach child {
	child/reset
    }
}

function â²completed ?â³ {
    var done = true
    âˆ€ Å¡.children child {
	done = done & child.â²completed ?â³
    }
    done
}

function handle (message) {
    Å¡.reset ()
    if (Å¡.isCompleted ()) {
	throw "internal error: container.handle called on completed container"
    }
    Å¡.internal_acceptInput (message)
    function send (port, data) {
	Å¡.outputs.push (new messageClass.Message (port, data, this, message))
    }
    Å¡.internal_runToCompletion (send)
    Å¡.outputs.push (new messageClass.Message ('$out', null, this, message))
}

function acceptInput (message) {
    Å¡.outputs = []
    Å¡.routingMap.forEach (connection => {
	if ("down" == connection.direction) {
	    var m = new messageClass.Message (connection.port, message.data, this, message)
	    var childOutputs = connection.receiver.handle (m, sendFunction)
	    Å¡.outputs = Å¡.internal_mergeOutputs (outputs, childOutputs)
	} else if ("passthrough" == connection.direction) {
	    var childOutputs = new messageClass.Message (connection.port, message.data, this, message)
	    Å¡.outputs = Å¡.internal_mergeOutputs (Å¡.outputs, childOutputs)
	}
    })    
}

function mergeOutputs (outputs, childOutputs) {
    // outputs & childOutputs are queues
    // copy from least recent to most recent
    var clonedOuts = Array.from (outputs)
    var childOuts = childOutputs.reverse ()
    childOuts.forEach (cout => {
	clonedOutputs.push (cout)
    })
    return clonedOutputs
}

function runToCompletion (sendFunction) {
    while (! Å¡.completed ()) {
	Å¡.step (sendFunction)
	Å¡.route (sendFunction)
    }
}

function step (sendFunction) {
    Å¡.children.forEach (child => {
	child.step (sendFunction)
    })
}

function route (sendFunction) {
    Å¡.routingMap.forEach (connection => {
	var deferredMessageStack = []
	if ("across" == connection.direction) {
	    var outputMessage = connection.sender.outputQueue [connection.sender.port]
	    var message = new messageClass.Message (connection.receiver.port, outputMessage.data, connection.sender, outputMessage)
	    deferredMessageStack.push ({'target': connection.receiver, 'message': message})
	} else if ("up" == connection.direction) {
	    var outputMessage = connection.sender.outputQueue [connection.sender.port]
	    var message = new messageClass.Message (connection.receiver.port, outputMessage.data, connection.sender, outputMessage)
	    send (connection.receiver.port, message)
	}
	deferredMessageStack.forEach (pair => {
	    pair.target.handle (pair.message, sendFunction)
	})
    })
}

