PseudoCode {

  main = toplevel+

  toplevel =
    | applySyntactic<FunctionDefinition>
    | applySyntactic<ProcedureDefinition>
    | applySyntactic<ConstructorDefinition>
    | applySyntactic<Statement>

  FunctionDefinition = "function" name FormalParameters? Block
  ProcedureDefinition = "procedure" name FormalParameters? Block
  ConstructorDefinition = "constructor" name FormalParameters? States Block

  States = "{" symbol* "}"

  Block = 
    | "{" BlockStatement* "}"

  BlockStatement =
    | FunctionDefinition
    | Statement
    
  Statement =
    | "synonym" name "‚â£" expr Block -- synonym
    | selfFieldName "‚â£" expr -- constructorsynonym
    | Block -- block
    | SelfStateDefinition -- selfStateDefinition
    | SelfStateUpdate -- selfStateUpdate
    | die operand* -- die
    | expr -- expr

  Parameters = "(" operand* ")"
  FormalParameters = "(" parameterDefinition* ")"

  operand = constant | value
  expr = operand

  constant =
    | applySyntactic<Message>
    | applySyntactic<BasicList>
    | applySyntactic<ListOfObjects>
    | string
    | symbol
    
  value =
    | applySyntactic<Funcall> -- funcall
    | applySyntactic<ClassInstantiation> -- instantiation
    | applySyntactic<MethodCall> -- methodCall
    | applySyntactic<FieldRef> -- fieldRef
    | parameterReference -- parameterRef
    | functionReference -- functionRef
    | procedureReference -- procedureRef
    | else operand -- else
    | stateQuery -- stateQuery
    | name -- name

  valueOperand = value

  stateQuery = stateQ operand applySyntactic<Block>

  Funcall = callop operand Parameters?

  ClassInstantiation = new name Parameters?
  MethodCall = value call name Parameters?
  ListOfObjects = ListHeader "[" UnnamedObject+ "]"
  ListHeader = headerOpen name+ headerClose
  BasicList = "[" name* "]"
  UnnamedObject = "{" expr* "}"
  Message =
    | messageBegin portOperand operand operand operand messageEnd -- withDebug
    | messageBegin portOperand operand messageEnd -- raw

  portOperand = port | valueOperand

  SelfStateDefinition = selfState "‚â£" expr
  SelfStateUpdate = expr "‚áí" selfState
  selfFieldName = selfName "." fieldName


  name =
    | compoundName
    | builtinName
    | selfName
    | basicName

  fieldName = nonSpecialName

  port = outport | inport

  FieldRef = value "." nonSpecialName
  selfState = selfName
  parameterReference = "ùúå" nonSpecialName
  parameterDefinition = parameterReference
  functionReference = lambda nonSpecialName
  procedureReference = proc nonSpecialName
  
  compoundName = "‚ù≤" (~nameBracket any)* "‚ù≥"
  basicName = nameFirst nameRest*
  nonSpecialName = ~selfName ~builtinName name
  
  delimiter = asciiBracket | asciiCharacter | unicodeBracket | unicodeCharacter
  asciiBracket = "(" | ")" | "{" | "}" | "[" | "]" | "<" | ">" 
  asciiCharacter = "#" | call | "." 
  call = "/"
  builtinChar = "‚âà"
  selfName = "≈°"
  unicodeBracket = headerOpen | headerClose | messageBegin | messageEnd | nameBracket
  messageBegin = "‚ü™"
  messageEnd = "‚ü´"
  headerOpen = "‚é®"
  headerClose = "‚é¨"
  nameBracket = "‚ù≤" | "‚ù≥"
  unicodeCharacter = new | builtinChar | lambda | proc | "‚ó¶"| "‚úï"

  string = sq (~sq any)* sq
  sq = "'"

  comment =  "/*" commentInnards* "*/" -- flat
  commentInnards =
    | "/*" commentInnards* "*/" -- rec
    | ~"/*" ~"*/" any -- flat

  nameFirst = ~unicodeCharacter letter
  nameRest = alnum | "_"

  builtinName = callop | die | else | stateQ | yes | no
  callop = builtinChar "call"
  die = builtinChar "die"
  else = builtinChar "else"
  stateQ = builtinChar "state"
  yes = builtinChar "yes"
  no = builtinChar "no"

  new = "‚Üµ"
  lambda = "Œª"
  proc = "≈æ"
  tag = "‚ñ´" nonSpecialName
  outport = "‚ó¶" nonSpecialName
  inport = "‚úï" nonSpecialName

  space += comment
}
