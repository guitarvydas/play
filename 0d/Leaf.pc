constructor Leaf (ùúåfunc) { ‚ú¶armed ‚ú¶completed } {} {
    ≈°.func ‚â£ ùúåfunc
    ≈°.reset ‚â£ ≈æreset
    ≈°.‚ù≤completed ?‚ù≥ ‚â£ Œª‚ù≤completed ?‚ù≥
    ≈°.handle ‚â£ ≈æhandle
    ≈°.step ‚â£ ≈æstep
    ≈°.outputs ‚â£ []

    ≈°/reset
    ‚ú¶armed ‚áí ≈°
}

function handle (ùúåmessage ùúåsendFunction) {
    #state ≈° {
        ‚ú¶armed {
            function send (ùúåport ùúådata ùúåtrace) {
                ≈°.outputs/push (‚ü™ ùúåport ùúådata ≈° ùúåtrace ‚ü´)
            }
            synonym val ‚â£ #call ≈°.func (ùúåmessage  ùúåsend) {
                ≈°.outputs/push (‚ü™ ‚ó¶out val ≈° ùúåmessage ‚ü´)
                ‚ú¶completed ‚áí ≈°
            }
        }
	‚ú¶completed {
            #die 'Leaf not armed'
        }        
    }
}

procedure step (ùúåsendFunction) {
    /*
    nothing to do
    Leaf calls its function once, then doesn't call it again until reset() has been called
    protocol: (1) call reset (2) call handle (3) call step 0 or more times
    in a Leaf, (3) step should only be called after (2) handle has been called, hence, there is nothing left to do in step
    in a Leaf (3) step is called only after the Leaf is in the completed state - step is a no-op in Leaf
    */
    #state ≈° {
        ‚ú¶completed {}
        ‚ú¶armed {
            #die 'internal error: Leaf/step called on armed leaf'
        }
    }
}

procedure reset {
    ‚ú¶armed ‚áí ≈° /* armed => ready to run function, completed => function already executed once */
}

function ‚ù≤completed ?‚ù≥ {
    #state ≈° {
        ‚ú¶armed     {#no}
        ‚ú¶completed {#yes}
   }
}
