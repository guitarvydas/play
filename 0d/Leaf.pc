constructor Leaf (ğœŒfunc) {
    { #armed #completed }
    Å¡.func â‰£ ğœŒfunc
    Å¡.reset â‰£ Î»reset
    Å¡.â²completed ?â³ â‰£ Î»â²completed ?â³
    Å¡.handle â‰£ Î»handle
    Å¡.step â‰£ Î»step
    Å¡.outputs â‰£ []

    Å¡/reset
    #armed â‡’ Å¡
}

function handle (ğœŒmessage ğœŒsendFunction) {
    â‰ˆstate Å¡ {
        #armed {
            function send (ğœŒport ğœŒdata ğœŒtrace) {
                Å¡.outputs/push (âŸª ğœŒport ğœŒdata Å¡ ğœŒtrace âŸ«)
            }
            synonym val â‰£ â‰ˆcall Å¡.func (ğœŒmessage  ğœŒsend) {
                Å¡.outputs/push (âŸª â—¦out val Å¡ ğœŒmessage âŸ«)
                #completed â‡’ Å¡
            }
        }
        â‰ˆelse {
            â‰ˆdie 'Leaf not armed'
        }        
    }
}

function step (ğœŒsendFunction) {
    /*
    nothing to do
    Leaf calls its function once, then doesn't call it again until reset() has been called
    protocol: (1) call reset (2) call handle (3) call step 0 or more times
    in a Leaf, (3) step should only be called after (2) handle has been called, hence, there is nothing left to do in step
    in a Leaf (3) step is called only after the Leaf is in the completed state - step is a no-op in Leaf
    */
    â‰ˆstate Å¡ {
        #completed {}
        â‰ˆelse {
            die 'internal error: Leaf/step called on armed leaf'
        }
    }
}

procedure reset {
    #armed â‡’ Å¡ /* armed => ready to run function, completed => function already executed once */
}

function â²completed ?â³ {
    â‰ˆstate Å¡ {
        #armed     {â‰ˆno}
        #completed {â‰ˆyes}
   }
}
