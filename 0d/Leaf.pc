/*
var messageClass = require ('./message.js')
*/

constructor Leaf (𝜌func) {
    š.func ≣ 𝜌func
    š.reset ≣ λreset
    š.isCompleted ≣ λisCompleted
    š.handle ≣ λhandle
    š.step ≣ λstep
    š.outputs ≣ []

    š/reset
    armed! ⇒ š.state
}

function handle (𝜌message 𝜌sendFunction) {
    cond š.state {
        armed! {
	    function send (𝜌port 𝜌data 𝜌trace) {
		š.outputs/push (⟪𝜌port 𝜌data š 𝜌trace⟫)
	    }
	    synonym val ≣ ≈call š.func (𝜌message  𝜌send) {
		š.outputs/push (⟪out! val š 𝜌message⟫)
		completed! ⇒ š.state
            }
        }
        ≈else {
	    die "Leaf not armed"
	}        
    }
}

function step (𝜌sendFunction) {
    /*
    nothing to do
    Leaf calls its function once, then doesn't call it again until reset() has been called
    protocol: (1) call reset (2) call handle (3) call step 0 or more times
    in a Leaf, (3) step should only be called after (2) handle has been called, hence, there is nothing left to do in step
    in a Leaf (3) step is called only after the Leaf is in the completed state - step is a no-op in Leaf
    */
    cond š.state {
        completed! {}
        ≈else {
	    die 'internal error: Leaf/step called on armed leaf'
    }
}

function reset () {
    armed! ⇒ š.state /* armed => ready to run function, completed => function already executed once */
}

function isCompleted () {
   š.state = "completed"
}

exports.Leaf = Leaf
