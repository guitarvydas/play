/*
var messageClass = require ('./message.js')
*/

constructor Leaf (ðœŒfunc) {
    Å¡.func â‰£ ðœŒfunc
    Å¡.reset â‰£ Î»reset
    Å¡.isCompleted â‰£ Î»isCompleted
    Å¡.handle â‰£ Î»handle
    Å¡.step â‰£ Î»step
    Å¡.outputs â‰£ []

    Å¡/reset
    armed! â‡’ Å¡.state
}

function handle (ðœŒmessage ðœŒsendFunction) {
    cond Å¡.state {
        armed! {
	    function send (ðœŒport ðœŒdata ðœŒtrace) {
		Å¡.outputs/push (âŸªðœŒport ðœŒdata Å¡ ðœŒtraceâŸ«)
	    }
	    synonym val â‰£ â‰ˆcall Å¡.func (ðœŒmessage  ðœŒsend) {
		Å¡.outputs/push (âŸªout! val Å¡ ðœŒmessageâŸ«)
		completed! â‡’ Å¡.state
            }
        }
        â‰ˆelse {
	    die "Leaf not armed"
	}        
    }
}

function step (ðœŒsendFunction) {
    /*
    nothing to do
    Leaf calls its function once, then doesn't call it again until reset() has been called
    protocol: (1) call reset (2) call handle (3) call step 0 or more times
    in a Leaf, (3) step should only be called after (2) handle has been called, hence, there is nothing left to do in step
    in a Leaf (3) step is called only after the Leaf is in the completed state - step is a no-op in Leaf
    */
    cond Å¡.state {
        completed! {}
        â‰ˆelse {
	    die 'internal error: Leaf/step called on armed leaf'
    }
}

function reset () {
    armed! â‡’ Å¡.state /* armed => ready to run function, completed => function already executed once */
}

function isCompleted () {
   Å¡.state = "completed"
}

exports.Leaf = Leaf
