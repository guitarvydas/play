constructor Container (ğœŒchildrenArray ğœŒmap) {
    // api for every Component
    Å¡.reset â‰£ Å¾reset
    Å¡.â²completed ?â³ â‰£ Î»â²completed ?â³
    Å¡.handle â‰£ Î»handle
    Å¡.step â‰£ Î»step
    Å¡.setChildren â‰£ Î»setChildren
    Å¡.setRoutings â‰£ Î»setRoutings
    Å¡.outputs â‰£ []

    // helper functions
    Å¡.internal_acceptInput â‰£ Å¾acceptInput
    Å¡.internal_mergeOutputs â‰£ Î»mergeOutputs
    Å¡.internal_route â‰£ Å¾route
    Å¡.internal_runToCompletion â‰£ Å¾runToCompletion

    Å¡.children â‰£ ğœŒchildrenArray
    â²set parent of childrenâ³ (Å¡)
    Å¡.routingMap â‰£ ğœŒmap
}

â‰ˆdeclare procedure â²set parent of childrenâ³ (self) {
  â‰ˆlang js (self) Â«
    self.children.forEach (child => {
	child.container = self;
    });
  Â»
}

procedure reset () {
  âˆ€ Å¡.children ğœchild {
    ğœchild/reset
  }
}

â‰ˆdeclare function â²completed ?â³ {
  â‰ˆlang js (self) Â«
    var done = true;
    self.children.forEach (child => {
	done = done & child.jsmangle ('â²completed ?â³') ();
    });
    return done;
  Â»
}

procedure handle (ğœŒmessage) {
    Å¡/reset
    â‰ˆstate Å¡ {
        #completed {
	    die 'internal error: container.handle called on completed container'
        }}    
    â‰ˆelse {}}
    Å¡/acceptInput (ğœŒmessage)
    â‰ˆinner function send (ğœŒport, ğœŒdata) {
	Å¡.outputs/push (âŸªğœŒport ğœŒdata Å¡ ğœŒmessageâŸ«)
    }
    Å¡/runToCompletion (Å¾send)
    Å¡.outputs.push (âŸªâ—¦out Ï• Å¡ ğœŒmessageâŸ«)
}

â‰ˆinternal procedure acceptInput (ğœŒmessage) {
    â‰ˆclear Å¡.outputs
    âˆ€ Å¡.routingMap ğœconnection {
        â‰ˆtag ğœconnection {
          â–«down {
	    synonym childOutputs â‰£ ğœconnection.receiver/handle (âŸªğœconnection.port ğœŒmessage.data Å¡ ğœŒmessageâŸ«, Å¾sendProcedure) {
                Å¡/mergeOutputs (childOutputs)
            }
}
	  â–«passthrough {
	    synonym childOutputs â‰£ [âŸªğœconnection.port ğœŒmessage.data Å¡ ğœŒmessageâŸ«, Å¾sendProcedure)] {
                Å¡/mergeOutputs (childOutputs)
            }
	  }
	  â‰ˆelse {}
    }
}

â‰ˆinternal function mergeOutputs (childOutputs) {
    /* merge childOutputs with self.outputs in situ */
    /* outputs & childOutputs are queues
       copy from least recent to most recent */
  â‰ˆlang js (childOutputs) Â«
    var clonedOuts = Array.from (self.outputs);
    var childOuts = childOutputs.reverse ();
    childOuts.forEach (cout => {
	clonedOutputs.push (cout);
    });
    return clonedOutputs;
  Â»
}

â‰ˆinternal procedure runToCompletion (Å¾sendProcedure) {
     â‰ˆjsâ‰ˆ Â«
         while (! Â«Å¡/completedÂ») {
             Â«Å¡/step (Å¾sendProcedure)Â»
             Â«Å¡/route (Å¾sendProcedure)Â»
         }
     Â»
     â‰ˆclâ‰ˆ Â«
         (loop while (not Â«Å¡/completedÂ»)
             do (progn Â«Å¡/step (Å¾sendProcedure)Â»
                       Â«Å¡/route (Å¾sendProcedure)Â»))
     Â»
}

procedure step (Å¾sendProcedure) {
    âˆ€ Å¡.children ğœchild {
	ğœchild/step (Å¾sendProcedure)
    }
}

function route (Å¾sendProcedure) {
    âˆ€ Å¡.routingMap ğœconnection {
        synonym â²deferred message stackâ³ [] {
            â‰ˆtag ğœconnection.direction {
                â–«across â–«up {
                    synonym â²output messageâ³ ğœconnection.sender.outputs {
                        â²deferred message stackâ³/push (â¨target messageâ¬ [{connection.receiver message}])
                    }
                â–«down â–«passThrough {}
            }
         }
    }
    âˆ€ â²deferred message stackâ³ ğœpair {
        ğœpair.target/handle (ğœpair.message, Å¾sendProcedure)
    }
}

